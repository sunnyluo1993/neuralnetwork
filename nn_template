"""
This is a template algorithm on Quantopian for you to adapt and fill in.
"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline
from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.factors import AverageDollarVolume
from quantopian.pipeline.filters.morningstar import Q500US
 
import numpy as np
import pytz

s2_setnumber = 3 

def initialize(context):
    context.portfolio_values = []
    context.cash_account = []
    context.open_order = []
    context.order_update = []
    context.order_stock = []
    context.track_commission = []
    context.track_positions = [[],[],[]]
    cash = context.portfolio.starting_cash / strategynumber
    for i in range(strategynumber):
        context.portfolio_values.append(cash)
        context.cash_account.append(cash)
        context.open_order.append([])
        context.order_update.append([])
        context.order_stock.append([])
        context.track_commission.append([])
        context.track_positions.append([[],[],[]])

    
    
    context.s2_stk = [[sid(3443),sid(33856),sid(8329)], [sid(2621),sid(2368),sid(8306)],[sid(24833),sid(5213),sid(16108)]]
    context.s2_n_dim_state = 3
    context.s2_y = []
    context.s2_x = []
    context.s2_beta = []
    context.s2_rollingbeta1 = []
    context.s2_rollingbeta2 = []
    context.s2_P = []
    context.s2_R = []
    context.s2_sqrt_Q = []
    context.s2_pos = []
    context.s2_open_finished = []
    context.s2_PL = []
    context.s2_cashpos = []
    context.s2_portpos = []
    context.s2_cycle_return = []
    context.s2_cumulative_return = []
    context.s2_opening_orderID = []
    context.s2_squaring = []
    context.s2_squaring_target = []
    context.s2_squaring_id = []
    context.s2_costbasis = []
    context.s2_stocks_filled = []
    context.s2_squaring_cost = []
    context.s2_squaring_finished = []
    context.s2_squaring_unfinished = []
    context.s2_stoploss = []
    context.s2_stoplossCount = []
    context.s2_uncertain = []
    context.s2_beta1std = []
    context.s2_beta2std = []
    context.s2_positions = [[],[]]
    
    for i in range(0,s2_setnumber):
        context.s2_y.append(context.s2_stk[i][0])
        x = []
        x.append(context.s2_stk[i][1])
        x.append(context.s2_stk[i][2])
        context.s2_x.append(x)
        context.s2_rollingbeta1.append([0,0,0,0,0])
        context.s2_rollingbeta2.append([0,0,0,0,0])
        P = np.zeros((context.s2_n_dim_state, context.s2_n_dim_state))
        context.s2_P.append(P)
        R = None
        context.s2_R.append(R)
        context.s2_sqrt_Q.append(0)
        pos = "none"
        context.s2_pos.append(pos)
        context.s2_open_finished.append(1)
        cashpos = context.portfolio.starting_cash / s2_setnumber
        portpos = context.portfolio.starting_cash / s2_setnumber
        context.s2_PL.append(0)
        context.s2_cashpos.append(cashpos)
        context.s2_portpos.append(portpos)
        context.s2_cycle_return.append([0,0,0])
        context.s2_cumulative_return.append([0,0,0])
        context.s2_stoploss.append(0)
        context.s2_stoplossCount.append(0)
        context.s2_squaring.append(0)
        context.s2_squaring_target.append([0,0,0])
        context.s2_squaring_id.append([0,0,0])
        context.s2_costbasis.append([0,0,0])
        context.s2_stocks_filled.append([0,0,0])
        context.s2_squaring_cost.append([0,0,0])
        context.s2_squaring_finished.append([1,1,1])
        context.s2_squaring_unfinished.append(0)
        context.s2_uncertain.append(0)
        context.s2_beta1std.append(0)
        context.s2_beta2std.append(0)
        
                       
    
    #delta will decide the value of the covariance of the transition noise
    context.s2_delta = 0.0001
    #Vw is the covariance of the transition noise 
    context.s2_Vw = context.s2_delta / (1 - context.s2_delta) * np.eye(context.s2_n_dim_state)
    #Ve is the covariance of the measurement noise
    context.s2_Ve = 0.25
    
    
    context.s2_beta = [[0.87, 0.27, 0.25],[0.34, -0.13, 0.23],[0.99, 0.48, 0.26]]

    context.s2_day = None
    context.s2_dateCounter = 0
    context.s2_activateDC = 0

def track_order(context, data, i):
    if (context.open_order[i] != []):
        for j in range(0,len(context.open_order[i])):
            order = get_order(context.open_order[i][j])
            if (order is not None):
                if (context.order_update[i][j] != 0):
                    last_filled = order.amount - context.order_update[i][j]
                    shares_in = order.filled - last_filled
                    #print "shares_in"
                    #print shares_in
                    cost = shares_in * data.current(context.order_stock[i][j],'price')
                    context.order_update[i][j] = order.amount - order.filled
                    new_commission = order.commission - context.track_commission[i][j]
                    cost = cost + new_commission
                    context.track_commission[i][j] = order.commission
                    
                    context.cash_account[i] = context.cash_account[i] - cost
                    
                if (context.order_stock[i][j] in context.track_positions[i][0]):
                    loc = context.track_positions[i][0].index(context.order_stock[i][j])
                    context.track_positions[i][1][loc] = context.track_positions[i][1][loc] + shares_in
                    context.track_positions[i][2][loc] = context.track_positions[i][2][loc] + cost
                else:
                    context.track_positions[i][0].append(context.s1_order_stock[i])
                    context.track_positions[i][1].append(order.filled)
                    context.track_positions[i][2].append(cost)
        
        remove = []
        for j in range(0,len(context.open_order[i])):
            
            if (context.order_update[i][j] == 0):
                remove.append(j)
        pop = 0 
        
        for j in range(0,len(remove)):  
            context.open_order[i].pop(remove[j]-pop)
            context.order_update[i].pop(remove[j]-pop)
            context.order_stock[i].pop(remove[j]-pop)
            context.track_commission[i].pop(remove[j]-pop)
            
            pop = pop + 1 
            
    
    context.portfolio_values[i] = context.cash_account[i]
    for j in range(len(context.track_positions[i][1])):
        context.portfolio_values[i] = context.portfolio_values[i] + data.current(context.track_positions[i][0][j],'price') * context.s1_positions[i][1][j]
    
def add_new_order(context, data, order, i):
    if (get_order(order) is not None): 
        context.open_order[i].append(order)
        context.order_update[i].append(get_order(order).amount)
        context.order_stock[i].append(get_order(order).sid)
        context.track_commission[i].append(0)

    
    
def s2_KF(context,data,i):
    x = np.hstack([[data.current(sec, 'price') for sec in context.s2_x[i]], 1.0]).reshape((1, context.s2_n_dim_state))
    y = data.current(context.s2_y[i], 'price')
    # update Kalman filter with latest price
    if context.s2_R[i] is not None:
        context.s2_R[i] = context.s2_P[i] + context.s2_Vw
    else:
        context.s2_R[i] = np.zeros((context.s2_n_dim_state, context.s2_n_dim_state))

    yhat = x.dot(context.s2_beta[i])
    Q = x.dot(context.s2_R[i]).dot(x.T) + context.s2_Ve
    sqrt_Q = np.sqrt(Q)
    sqrt_Q = sqrt_Q[0][0]
    context.s2_sqrt_Q[i] = sqrt_Q
    e = y - yhat
    K = context.s2_R[i].dot(x.T) / Q
    beta = context.s2_beta[i] + K.flatten() * e
    context.s2_beta[i] = beta.tolist()
    context.s2_rollingbeta1[i][4] = context.s2_rollingbeta1[i][3]
    context.s2_rollingbeta1[i][3] = context.s2_rollingbeta1[i][2]
    context.s2_rollingbeta1[i][2] = context.s2_rollingbeta1[i][1]
    context.s2_rollingbeta1[i][1] = context.s2_rollingbeta1[i][0]
    context.s2_rollingbeta1[i][0] = context.s2_beta[i][0]
    context.s2_rollingbeta2[i][4] = context.s2_rollingbeta2[i][3]
    context.s2_rollingbeta2[i][3] = context.s2_rollingbeta2[i][2]
    context.s2_rollingbeta2[i][2] = context.s2_rollingbeta2[i][1]
    context.s2_rollingbeta2[i][1] = context.s2_rollingbeta2[i][0]
    context.s2_rollingbeta2[i][0] = context.s2_beta[i][1]  
    context.s2_beta1std[i] = np.std(context.s2_rollingbeta1[i])
    context.s2_beta2std[i] = np.std(context.s2_rollingbeta2[i])
    
    context.s2_P[i] = context.s2_R[i] - K * x.dot(context.s2_R[i])
    if context.s2_uncertain[i] == 1:
        if (context.s2_beta1std[i] < 0.02) & (context.s2_beta2std[i] < 0.02):
            context.s2_uncertain[i] = 0 
    print context.s2_beta    

def before_trading_start(context,data):
    
    context.s2_activateDC = 1
    for i in range(0,s2_setnumber):
        KF(context,data,i)
    for i in range(0,s2_setnumber):
        if context.s2_squaring[i] == 1:
            context.s2_squaring_unfinished[i] = 1
            for j in range(0,len(context.s2_stk[i])):
                context.s2_squaring_cost[i][j] = context.s2_squaring_cost[i][j] + get_order(context.s2_squaring_id[i][j]).commission
    record(set3beta1 = context.s2_beta[2][0])
    record(set3beta2 = context.s2_beta[2][1])
        
def s2_find_signal(context, data, i):
    if context.s2_open_finished[i] == 0:
        open_order_sum = 0 
        for sec in context.s2_stk[i]:
            open_order_sum = open_order_sum + len(get_open_orders(sec))
        if open_order_sum == 0:
            context.s2_open_finished[i] = 1
            print "portfolio {} {} position opened".format(i+1, context.s2_pos[i])
            for j in range(0,len(context.s2_stk[i])):        
                context.s2_costbasis[i][j] = context.s2_portfolio.positions[context.s2_stk[i][j]].amount*context.s2_portfolio.positions[context.s2_stk[i][j]].cost_basis
                context.s2_cashpos[i] = context.s2_cashpos[i] - context.s2_costbasis[i][j]    
            
        #print "open order left", open_order_sum    
    else:
        portpos = context.s2_portfolio.positions[context.s2_stk[i][0]].amount*data.current(context.s2_stk[i][0], 'price') + context.s2_portfolio.positions[context.s2_stk[i][1]].amount*data.current(context.s2_stk[i][1], 'price') + context.s2_portfolio.positions[context.s2_stk[i][2]].amount*data.current(context.s2_stk[i][2], 'price') + context.s2_cashpos[i]
        PL = portpos - context.s2_portpos[i]
        y = data.current(context.s2_y[i], 'price')
        x = [data.current(sec, 'price') for sec in context.s2_x[i]]
        spread = y - x[0] * context.s2_beta[i][0] - x[1] * context.s2_beta[i][1] - context.s2_beta[i][2]
        #when there is no position, check for signals
        if context.s2_pos[i] == "none":
            if (spread < -0.5*context.s2_sqrt_Q[i]):
                context.s2_pos[i] = 'long'
                s2_my_long(context,data,i)
                
                #print spread
                #consider linear strategy
            elif (spread > 0.5*context.s2_sqrt_Q[i]):    
                context.s2_pos[i] = 'short'
                s2_my_short(context,data,i)
                #print spread

        if context.s2_pos[i] == "long":
            if PL < context.s2_stoploss[i]:
                context.s2_stoplossCount[i] = context.s2_stoplossCount[i] + 1 
                print "portfolio {} stoploss {}".format(i+1, context.s2_stoplossCount[i])
                if (context.s2_beta1std[i] > 0.03) or (context.s2_beta2std[i] > 0.03):
                    context.s2_uncertain[i] = 1 
                    context.s2_stoplossCount[i] = 0
                    
                    s2_start_squaring(context,data,i)
                 

                if context.s2_stoplossCount[i] > 390:
                    if (context.s2_beta1std[i] > 0.01) or (context.s2_beta2std[i] > 0.01):
                        context.s2_uncertain[i] = 1 
                        context.s2_stoplossCount[i] = 0

                        start_squaring(context,data,i)
                     
                        
            elif spread > 0:
                context.s2_stoplossCount[i] = 0
                s2_start_squaring(context,data,i)
         
        if context.s2_pos[i] == "short":
            if PL < context.s2_stoploss[i]:
                context.s2_stoplossCount[i] = context.s2_stoplossCount[i] + 1 
                print "portfolio {} stoploss {}".format(i+1, context.s2_stoplossCount[i])
                if (context.s2_beta1std[i] > 0.03) or (context.s2_beta2std[i] > 0.03):
                    context.s2_uncertain[i] = 1 
                    context.s2_stoplossCount[i] = 0

                    s2_start_squaring(context,data,i)
              
                if context.s2_stoplossCount[i] > 390:
                    if (context.s2_beta1std[i] > 0.01) or (context.s2_beta2std[i] > 0.01):
                        context.s2_uncertain[i] = 1 
                        context.s2_stoplossCount[i] = 0
                        s2_start_squaring(context,data,i)
               

            elif spread < 0:
                context.s2_stoplossCount[i] = 0
                s2_start_squaring(context,data,i)
       


                   
def s2_start_squaring(context, data, i):
    context.s2_squaring[i] = 1 
    for j in range(0,len(context.s2_stk[i])): 
        loc = context.track_positions[1][0].index(context.s2_stk[i][j])
        context.s2_squaring_target[i][j] = -1* context.track_positions[1][1][loc]
        context.s2_squaring_id[i][j] = order(context.s2_stk[i][j], context.s2_squaring_target[i][j])
        context.open_order[1].append(context.s2_squaring_id[i][j])
        
        context.s2_squaring_finished[i][j] = 0
    print "starting to square portfolio {}".format(i+1)
    

def s2_finish_squaring(context,data,i):
    for j in range(0, len(context.s2_stk[i])):
        context.s2_squaring_cost[i][j] = context.s2_squaring_cost[i][j] + get_order(context.s2_squaring_id[i][j]).commission
        context.s2_cashpos[i] = context.s2_cashpos[i] - context.s2_squaring_cost[i][j]
        context.s2_squaring_cost[i][j] = 0
        context.s2_squaring_target[i][j] = 0
        context.s2_stocks_filled[i][j] = 0
    context.s2_PL[i] = context.s2_cashpos[i] - context.s2_portpos[i]
#    cycle_return = context.s2_PL[i] / context.s2_portpos[i]
    context.s2_cycle_return[i] = context.s2_PL[i] / context.s2_portpos[i]
    context.s2_portpos[i] = context.s2_cashpos[i]
    context.s2_cumulative_return[i] = context.s2_portpos[i] / (context.s2_portfolio.starting_cash / s2_setnumber) - 1 
    
    context.s2_squaring[i] = 0
    print "portfolio {} {} position squared, returned {:.1%} this cycle, {:.1%} cumulatively.".format(i+1,context.s2_pos[i],context.s2_cycle_return[i], context.s2_cumulative_return[i])
    context.s2_pos[i] = "none"
    
def track_positions(context,data)        

    

def handle_data(context, data):
    
    if context.s2_activateDC==1:
        context.s2_dateCounter = context.s2_dateCounter+1
        context.s2_activateDC=0
    if context.s2_dateCounter > 0:
        for i in range(0,s2_setnumber):
            if context.s2_squaring[i] == 1:
                if context.s2_squaring_unfinished[i] == 1:
                    for j in range(0, len(context.s2_stk[i])):
                        if context.s2_squaring_unfinished[i] == 1:
                            #print context.s2_stk[i][j]
                            #print context.s2_squaring_target[i][j]
                            #print context.s2_stocks_filled[i][j]
                            context.s2_squaring_target[i][j] = context.s2_squaring_target[i][j] - context.s2_stocks_filled[i][j]
                            if context.s2_squaring_target[i][j] != 0:
                                #print context.s2_squaring_target[i][j]
                                context.s2_squaring_id[i][j] = order_target_percent(context.s2_stk[i][j],0)
                                #print context.s2_squaring_id[i][j]
                            context.s2_stocks_filled[i][j] = 0 
                    context.s2_squaring_unfinished[i] = 0
                    
                for j in range(0, len(context.s2_stk[i])):  
                    #print context.s2_squaring_id[i][j]
                    if context.s2_squaring_finished[i][j] == 0:
                        new_order = get_order(context.s2_squaring_id[i][j]).filled - context.s2_stocks_filled[i][j]
                        new_cost = data.current(context.s2_stk[i][j], 'price') * new_order
                        context.s2_stocks_filled[i][j] = get_order(context.s2_squaring_id[i][j]).filled
                        context.s2_squaring_cost[i][j] = context.s2_squaring_cost[i][j] + new_cost
                        if get_order(context.s2_squaring_id[i][j]).filled == context.s2_squaring_target[i][j]:
                            context.s2_squaring_finished[i][j] = 1
                        
                if context.s2_squaring_finished[i] == [1,1,1]:
                    finish_squaring(context,data,i)
            else:
                if context.s2_uncertain[i] == 0:
                    exchange_time = get_datetime().astimezone(pytz.timezone('US/Eastern'))
                    if exchange_time.hour < 15:
                        if exchange_time.hour >= 9:
                            s2_find_signal(context,data,i)


def s2_my_long(context,data,i):
    print "longing set {}".format(i+1)
    context.s2_open_finished[i] = 0
    y = data.current(context.s2_y[i], 'price')
    x = [data.current(sec, 'price') for sec in context.s2_x[i]]
    spread = y - x[0] * context.s2_beta[i][0] - x[1] * context.s2_beta[i][1] - context.s2_beta[i][2]
    ratio = spread / context.s2_sqrt_Q[i]
    ratio = np.absolute(ratio)
    #print "ratio1"
    #print ratio
    ratio = np.amin([0.5*ratio,0.5])
    #print "ratio capped"
    #print ratio
    if (context.s2_beta[i][0] >0) & (context.s2_beta[i][1] > 0):
       # print "case1"
        order1 = order_target_value(context.s2_y[i], ratio*context.s2_portpos[i])
        stock1T = context.s2_beta[i][0]*data.current(context.s2_x[i][0], 'price')
        stock2T = context.s2_beta[i][1]*data.current(context.s2_x[i][1], 'price')
        stock1percent = stock1T/(stock1T + stock2T + context.s2_beta[i][2])
        stock2percent = stock2T/(stock1T + stock2T + context.s2_beta[i][2])
        """
        context.s2_stk1pos[i] = ratio*context.s2_portpos[i]
        context.s2_stk2pos[i] = -1*ratio*stock1percent*context.s2_portpos[i] 
        context.s2_stk3pos[i] = -1*ratio*stock2percent*context.s2_portpos[i]
        context.s2_cashpos[i] = context.s2_portpos[i] - context.s2_stk1pos[i] - context.s2_stk2pos[i] - context.s2_stk3pos[i]
        """
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        order2 = order_target_value(context.s2_x[i][0], -1*ratio*stock1percent*context.s2_portpos[i])
        order3 = order_target_value(context.s2_x[i][1], -1*ratio*stock2percent*context.s2_portpos[i])
       
    elif (context.s2_beta[i][0] >0) & (context.s2_beta[i][1] < 0):
       # print "case2"
        order2 = order_target_value(context.s2_x[i][0], -1*ratio*context.s2_portpos[i])
        yT = data.current(context.s2_y[i], 'price')
        stock2T = context.s2_beta[i][1]*data.current(context.s2_x[i][1], 'price')
        ypercent = yT/(yT - stock2T - context.s2_beta[i][2])
        stock2percent = -1 * stock2T/(yT - stock2T - context.s2_beta[i][2])
        
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        
        order3 = order_target_value(context.s2_x[i][1], ratio*stock2percent*context.s2_portpos[i])
        order1 = order_target_value(context.s2_y[i], ratio*ypercent*context.s2_portpos[i])

    elif (context.s2_beta[i][0] <0) & (context.s2_beta[i][1] > 0):
        #print "case3"
        order3= order_target_value(context.s2_x[i][1], -1*ratio)
        yT = data.current(context.s2_y[i], 'price')
        stock1T = context.s2_beta[i][0]*data.current(context.s2_x[i][0], 'price')
        ypercent = yT/(yT - stock1T - context.s2_beta[i][2])
        stock1percent = -1* stock1T/(yT - stock1T - context.s2_beta[i][2])
        """
        context.s2_stk1pos[i] = ratio*ypercent*context.s2_portpos[i]
        context.s2_stk2pos[i] = 1*ratio*stock1percent*context.s2_portpos[i]
        context.s2_stk3pos[i] = -1*ratio*context.s2_portpos[i]
        
        context.s2_cashpos[i] = context.s2_portpos[i] - context.s2_stk1pos[i] - context.s2_stk2pos[i] - context.s2_stk3pos[i]
        """
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        order2= order_target_value(context.s2_x[i][0], ratio*stock1percent*context.s2_portpos[i])
        order1= order_target_value(context.s2_y[i], ratio*ypercent*context.s2_portpos[i])   
    
    add_new_order(context, data, order1, 1)
    add_new_order(context, data, order2, 1)
    add_new_order(context, data, order3, 1)

def s2_my_short(context,data,i):    
    print "shorting set {}".format(i+1)
    context.s2_open_finished[i] = 0
    y = data.current(context.s2_y[i], 'price')
    x = [data.current(sec, 'price') for sec in context.s2_x[i]]
    spread = y - x[0] * context.s2_beta[i][0] - x[1] * context.s2_beta[i][1] - context.s2_beta[i][2]
    ratio = spread / context.s2_sqrt_Q[i]
    ratio = np.absolute(ratio)
    #print "ratio1"
    #print ratio
    ratio = np.amin([0.5*ratio,0.5])
    #print "ratio capped"
    #print ratio
    if (context.s2_beta[i][0] >0) & (context.s2_beta[i][1] > 0):
       # print "case1"
        order1= order_target_value(context.s2_y[i], -1*ratio*context.s2_portpos[i])
        stock1T = context.s2_beta[i][0]*data.current(context.s2_x[i][0], 'price')
        stock2T = context.s2_beta[i][1]*data.current(context.s2_x[i][1], 'price')
        stock1percent = stock1T/(stock1T + stock2T + context.s2_beta[i][2])
        stock2percent = stock2T/(stock1T + stock2T + context.s2_beta[i][2])
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        order2= order_target_value(context.s2_x[i][0], 1*ratio*stock1percent*context.s2_portpos[i])
        order3= order_target_value(context.s2_x[i][1], 1*ratio*stock2percent*context.s2_portpos[i])
       
    elif (context.s2_beta[i][0] >0) & (context.s2_beta[i][1] < 0):
       # print "case2"
        order2= order_target_value(context.s2_x[i][0], 1*ratio*context.s2_portpos[i])
        yT = data.current(context.s2_y[i], 'price')
        stock2T = context.s2_beta[i][1]*data.current(context.s2_x[i][1], 'price')
        ypercent = yT/(yT - stock2T - context.s2_beta[i][2])
        stock2percent = -1 * stock2T/(yT - stock2T - context.s2_beta[i][2])
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        order3= order_target_value(context.s2_x[i][1], -1*ratio*stock2percent*context.s2_portpos[i])
        order1= order_target_value(context.s2_y[i], -1*ratio*ypercent*context.s2_portpos[i])

    elif (context.s2_beta[i[0]] <0) & (context.s2_beta[i[1]] > 0):
        #print "case3"
        order3= order_target_value(context.s2_x[i][1], 1*ratio*context.s2_portpos[i])
        yT = data.current(context.s2_y[i], 'price')
        stock1T = context.s2_beta[i][0]*data.current(context.s2_x[i][0], 'price')
        ypercent = yT/(yT - stock1T - context.s2_beta[i][2])
        stock1percent = -1* stock1T/(yT - stock1T - context.s2_beta[i][2])
        context.s2_stoploss[i] = -0.05 * context.s2_portpos[i]
        order2= order_target_value(context.s2_x[i][0], -1*ratio*stock1percent*context.s2_portpos[i])
        order1= order_target_value(context.s2_y[i], -1*ratio*ypercent*context.s2_portpos[i])
    add_new_order(context, data, order1, 1)
    add_new_order(context, data, order2, 1)
    add_new_order(context, data, order3, 1)

