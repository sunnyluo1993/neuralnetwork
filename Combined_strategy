"""
This is a template algorithm on Quantopian for you to adapt and fill in.
"""
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline
from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.factors import AverageDollarVolume
from quantopian.pipeline.filters.morningstar import Q1500US
import numpy as np
import pytz
from collections import defaultdict
strategynumber = 2 

class dotDict:
    #This class allows .notation for organizing data in context
    def __init__(self):
        pass
    
def initialize(context):
    #orders ID stored for those that are still open
    context.open_order = []
    #how much of the is left for the order. 0 means it is finished 
    context.order_update = []
    #what stock is being ordered 
    context.order_stock = []
    #commission spent for a specific order 
    context.track_commission = []
    #open up a data base for each strategy for these 4 variables
    for i in range(strategynumber):
        context.open_order.append([])
        context.order_update.append([])
        context.order_stock.append([])
        context.track_commission.append([])
    context.context = {}
    #open up a data base that will track each strategy as a portfolio just like context.portfolio
    for i in range(strategynumber):
        context.context[i] = dotDict()
        strategy_init(context,i)
    
    #initialize each strategy in this main initialize
    s0_initialize(context)
    s1_initialize(context)

def strategy_init(context, i):
    context.context[i].portfolio = dotDict()
    context.context[i].portfolio.starting_cash = context.portfolio.starting_cash / strategynumber 
    context.context[i].portfolio.capital_used = 0
    context.context[i].portfolio.cash = context.portfolio.starting_cash / strategynumber 
    context.context[i].portfolio.portfolio_value = context.context[i].portfolio.cash
    context.context[i].portfolio.pnl = 0
    
    #this position dictionary defaults each key with a 0 of amount and cost basis.  
    context.context[i].portfolio.positions = {}
    default = dotDict()
    default.amount = 0 
    default.cost_basis = 0
    context.context[i].portfolio.positions = defaultdict(lambda: default, context.context[i].portfolio.positions)
    
    context.context[i].portfolio.positions_value = 0 
    context.context[i].portfolio.returns = 0
    
    context.context[i].portfolio.start_date = context.portfolio.start_date
        

def before_trading_start(context,data):   
    #each order will no longer be open after the end of a day. For safety, I set all the open order related variables to empty. 
    context.open_order = []
    context.order_update = []
    context.order_stock = []
    context.track_commission = []
    for i in range(strategynumber):
        context.open_order.append([])
        context.order_update.append([])
        context.order_stock.append([])
        context.track_commission.append([])
    
    #I rerun the portfolio related variables everyday before market start based on the new stock price 
        context.context[i].portfolio.positions_value = 0
        stock_list = list(context.context[i].portfolio.positions.keys())
        for j in range(len(stock_list)):
            context.context[i].portfolio.positions[stock_list[j]].last_sale_price =  context.portfolio.positions[stock_list[j]].last_sale_price
            context.context[i].portfolio.positions_value =  context.context[i].portfolio.positions_value + context.context[i].portfolio.positions[stock_list[j]].last_sale_price * context.context[i].portfolio.positions[stock_list[j]].amount   
        context.context[i].portfolio.portfolio_value = context.context[i].portfolio.cash + context.context[i].portfolio.positions_value 
        context.context[i].portfolio.pnl = context.context[i].portfolio.portfolio_value - context.context[i].portfolio.starting_cash
        context.context[i].portfolio.returns = context.context[i].portfolio.pnl / context.context[i].portfolio.starting_cash   
    record(s1_returns = context.context[1].portfolio.returns)
    #this prints for demo purposes 
    
    print context.context[0].portfolio.cash
    print context.context[1].portfolio.cash
    s0_before_trading_start(context,data)
    s1_before_trading_start(context,data)
    
def handle_data(context,data):
    #Track order serves to updates each strategies' portfolio position based on new orders and updated stock price
    for i in range(strategynumber):
        track_order(context,data,i)
    #calling all handle_data at this main one 
    s1_handle_data(context,data)
    
    
#this function serves to update portfolio information of each strategy. The i specifies which strategy this is. This runs at handle data which runs every minute
def track_order(context, data, i):
    #list all the stocks with a position 
    
    #check if we have any open orders for this portfolio
    if (context.open_order[i] != []):
        for j in range(0,len(context.open_order[i])):
            #get the order information for each order
            order = get_order(context.open_order[i][j])
            
            if (order is not None):
                #make sure this order is not yet finished 
                if (context.order_update[i][j] != 0):
                    #order.amount gives us how much we want to order, and order_update gives us how much we needed to order in the LAST minute instance. Hence, last_filled is how much the order is filled last minute
                    last_filled = order.amount - context.order_update[i][j]
                    #order.filled gives how much is ordered minute, hence this difference is how much we have filled from this minute compare to the last minute
                    shares_in = order.filled - last_filled
                    #this is cost of this order for this specific minute based on how much is ordered and the current stock price 
                    cost = shares_in * data.current(context.order_stock[i][j],'price')
                    #we now update how much we still need to order for next minute to compare
                    context.order_update[i][j] = order.amount - order.filled
                    #we now calculate how much commission fee is generated for this minute. track commission starts with 0 at make_order
                    new_commission = order.commission - context.track_commission[i][j]
                    #we add the new_comission to the whole cost of this minute for this order
                    cost = cost + new_commission
                    #we update the new commission paid for this order 
                    context.track_commission[i][j] = order.commission
                    
                    #we update the cash value of this portfolio based on how much stocks is purchased
                    context.context[i].portfolio.cash = context.context[i].portfolio.cash - cost
                    context.context[i].portfolio.capital_used = context.context[i].portfolio.capital_used - cost
                
                #we calculate the total cost of the stock at the last minute 
                old_cost = context.context[i].portfolio.positions[context.order_stock[i][j]].amount * context.context[i].portfolio.positions[context.order_stock[i][j]].cost_basis
                #we update how much of the stock we have in the strategy portfolio after this minute
                context.context[i].portfolio.positions[context.order_stock[i][j]].amount = shares_in + context.context[i].portfolio.positions[context.order_stock[i][j]].amount
                
                #we update the cost_basis here 
                if (context.context[i].portfolio.positions[context.order_stock[i][j]].amount != 0):
                    context.context[i].portfolio.positions[context.order_stock[i][j]].cost_basis = (cost + old_cost)/ context.context[i].portfolio.positions[context.order_stock[i][j]].amount
                else:
                    context.context[i].portfolio.positions[context.order_stock[i][j]].cost_basis = 0   
                    
                    
        #we data for orders that is already finished.             
        remove = []
        for j in range(0,len(context.open_order[i])):
            
            if (context.order_update[i][j] == 0):
                remove.append(j)
        pop = 0 
        
        for j in range(0,len(remove)):  
            context.open_order[i].pop(remove[j]-pop)
            context.order_update[i].pop(remove[j]-pop)
            context.order_stock[i].pop(remove[j]-pop)
            context.track_commission[i].pop(remove[j]-pop)
            
            pop = pop + 1 
            
    #listing stocks with a position 
    stock_list = list(context.context[i].portfolio.positions.keys())
    
    #update portfolio position and other variables based on current stock price 
    context.context[i].portfolio.positions_value  = 0 
    for j in range(len(stock_list)):
        context.context[i].portfolio.positions[stock_list[j]].last_sale_price =  context.portfolio.positions[stock_list[j]].last_sale_price
        context.context[i].portfolio.positions_value =  context.context[i].portfolio.positions_value + data.current(stock_list[j],'price') * context.context[i].portfolio.positions[stock_list[j]].amount
    
    context.context[i].portfolio.portfolio_value = context.context[i].portfolio.cash + context.context[i].portfolio.positions_value 
    context.context[i].portfolio.pnl = context.context[i].portfolio.portfolio_value - context.context[i].portfolio.starting_cash
    context.context[i].portfolio.returns = context.context[i].portfolio.pnl / context.context[i].portfolio.starting_cash 
    for j in range(len(stock_list)):
        if (context.context[i].portfolio.positions[stock_list[j]].amount == 0):
            context.context[i].portfolio.positions.pop(stock_list[j], None)         
            
#this is the function that all strategy will use to make any order
#order method has to be one of the 6: order, order_value, order_target, order_percent, order_target_value, order_target_percent
#sid is the stock
#amount is the second field that users fill in for which ever order method that signifies the percentage or share number dependeing on the order method
#OrderType allows the stoploss and limit feature. Please let out the "style =" part. Please input 0 if this is a market order (market order is the default order type in the normal order functions) 
#i shows which strategy this is ordering for
def make_order(context, data, order_method, sid, amount, OrderType, i):
    stock_list = list(context.context[i].portfolio.positions.keys())
    #create a key for stocks that is not in the postiion dictionary 
    if (sid not in stock_list):
        context.context[i].portfolio.positions[sid] = dotDict()
        context.context[i].portfolio.positions[sid].amount = 0
        context.context[i].portfolio.positions[sid].cost_basis = 0
        context.context[i].portfolio.positions[sid].sid = context.portfolio.positions[sid].sid
        context.context[i].portfolio.positions[sid].last_sale_price =  context.portfolio.positions[sid].last_sale_price
    
    if OrderType == 0:
            OrderType = MarketOrder()
    if (order_method is order):
        my_order = order(sid, amount, style = OrderType)
    elif (order_method is order_value):
        my_order = order_value(sid, amount, style = OrderType)

    elif (order_method is order_percent):
        value = context.context[i].portfolio.portfolio_value * amount
        my_order = order_value(sid, value, style = OrderType)
    elif (order_method is order_target):   
        target = amount - context.context[i].portfolio.positions[sid].amount
        my_order = order(sid, target, style = OrderType)
    elif (order_method is order_target_value):  
        holding_value = data.current(sid,'price')*context.context[i].portfolio.positions[sid].amount
        ordering_value = amount - holding_value
        my_order = order_value(sid, ordering_value, style = OrderType)
        
    elif (order_method is order_target_percent):
        holding_value = data.current(sid,'price')*context.context[i].portfolio.positions[sid].amount
        ordering_value = amount*context.context[i].portfolio.portfolio_value - holding_value
        my_order = order_value(sid, ordering_value, style = OrderType)
    else:
        my_order = 0
        print "error in ordering"


    if (get_order(my_order) is not None): 
        context.open_order[i].append(my_order)
        context.order_update[i].append(get_order(my_order).amount)
        context.order_stock[i].append(sid)
        context.track_commission[i].append(0)
    #just like the normal order functions, this will return the order id 
    return my_order      

def s0_initialize(context):
    #Parameters
    context.s0_signalFetchFile = "https://dl.dropboxusercontent.com/s/uvuqnqzbzf7p1c7/dailySignal.csv"
    context.s0_stockFetchFile  = "https://dl.dropboxusercontent.com/s/napvsyl53qn7hfl/dailySUSIR.csv"
    context.s0_numberOfPF      = 5
    context.s0_daysPerUpdate   = 5
#Note that holding period for each portfolio is context.s0_numberOfPF * context.s0_daysPerUpdate
    context.s0_longStockNum    = 20
    context.s0_shortStockNum   = 20
    context.s0_pfSizeScale     = 3
    context.s0_longOverShort   = 0.52

    
    fetch_csv(context.s0_stockFetchFile,
        pre_func=s0_previewFetch,    
        date_column = "date", 
        date_format = '%y/%m/%d')
    
    #Accounting variables
    context.s0_counters          = s0_dotDict()
    context.s0_counters.day      = -1
    context.s0_toTrade           = s0_dotDict()
    context.s0_rotPFs            = [s0_dotDict() for x in range(context.s0_numberOfPF)]
    context.s0_longOrderID       = [None for x in range(context.s0_longStockNum)]
    context.s0_shortOrderID      = [None for x in range(context.s0_shortStockNum)]
    #Counter for which portfolio to rotate
    context.s0_pfToUpdate        = 0
    for x in range(context.s0_numberOfPF):
        #Initialize all positions to zero so that first round of liquidation works.
        context.s0_rotPFs[x].numLongPos     = [0 for y in range(context.s0_longStockNum)]
        context.s0_rotPFs[x].numShortPos    = [0 for y in range(context.s0_shortStockNum)]
        #symbol('SPY') is just a placeholder for an SID 
        context.s0_rotPFs[x].longStockSID   = [symbol('SPY') for y in range(context.s0_longStockNum)]
        context.s0_rotPFs[x].shortStockSID  = [symbol('SPY') for y in range(context.s0_shortStockNum)]
        
    schedule_function(
        func=s0_rebalance,
        date_rule=date_rules.every_day(),
        time_rule=time_rules.market_open(minutes=1),
        half_days=True
    )
    
    schedule_function(
        func=s0_check_end_of_day_position,
        date_rule=date_rules.every_day(),
        time_rule=time_rules.market_close(minutes=1),
        half_days=True        
    )
   
    
    
def s0_before_trading_start(context,data):
    context.s0_counters.day = context.s0_counters.day + 1    
    if (context.s0_counters.day%context.s0_daysPerUpdate == 0):
        log.info("Rebalancing portfolio: " + str(context.s0_pfToUpdate))
        s0_selectStocks(context,data)
        s0_fix_weights(context,data)

def s0_selectStocks(context,data):
    #Isolating the assets to trade
    allSUSIR                        = [data.current(x,'susir') for x in data.fetcher_assets]
    assetTrade                      = [x for (y,x) in sorted(zip(allSUSIR,data.fetcher_assets))]
    context.s0_toTrade.shortStockSID   = assetTrade[:context.s0_shortStockNum]
    context.s0_toTrade.longStockSID    = assetTrade[-context.s0_longStockNum:]
    

def s0_rebalance(context,data):
    if (context.s0_counters.day%context.s0_daysPerUpdate == 0):
        #Liquidate everything first according to the number of shares
        pF    = context.s0_rotPFs[context.s0_pfToUpdate] 
        for idx, security in enumerate(pF.longStockSID):
            make_order(context, data, order, security, -pF.numLongPos[idx], 0, 0)
        for idx, security in enumerate(pF.shortStockSID):
            make_order(context, data, order, security, -pF.numShortPos[idx], 0, 0)
    
        #Reform the portfolio and construct orderIDs for obtaining shares ordered
        for idx, security in enumerate(context.s0_toTrade.longStockSID):
            if data.can_trade(security):
                context.s0_longOrderID[idx] = make_order(context, data, order_value, security, context.s0_longOverShort*context.s0_toTrade.tradeVal/float(context.s0_longStockNum), 0, 0) 
                context.s0_rotPFs[context.s0_pfToUpdate].longStockSID[idx] = security
            else:
                context.s0_longOrderID[idx] = make_order(context, data, order_value, sid(8554), 0, 0, 0) 
        for idx, security in enumerate(context.s0_toTrade.shortStockSID):
            if data.can_trade(security):
                context.s0_shortOrderID[idx] = make_order(context, data, order_value, security, -(1-context.s0_longOverShort)*context.s0_toTrade.tradeVal/float(context.s0_shortStockNum), 0, 0)                                         
                context.s0_rotPFs[context.s0_pfToUpdate].shortStockSID[idx] = security
            else:
                context.s0_shortOrderID[idx] = make_order(context, data, order_value, sid(8554), 0, 0, 0) 
            
def s0_fix_weights(context,data):
    context.s0_toTrade.tradeVal   = context.s0_pfSizeScale*context.context[0].portfolio.portfolio_value/float(context.s0_numberOfPF)

    
    
def s0_check_end_of_day_position(context,data):
    if (context.s0_counters.day%context.s0_daysPerUpdate == 0):
        
        for idx, orders in enumerate(context.s0_longOrderID):
            bla = get_order(orders)
            #If trying to order a dropped asset, it will go to none.
            if (bla is not None):
                context.s0_rotPFs[context.s0_pfToUpdate].numLongPos[idx] = bla.filled
                cancel_order(orders)
            else:
                context.s0_rotPFs[context.s0_pfToUpdate].numLongPos[idx] = 0
            
    
        for idx, orders in enumerate(context.s0_shortOrderID):
            bla = get_order(orders)
            if (bla is not None):
                context.s0_rotPFs[context.s0_pfToUpdate].numShortPos[idx] = bla.filled
                cancel_order(orders)
            else:
                context.s0_rotPFs[context.s0_pfToUpdate].numShortPos[idx] = 0

        x = context.s0_pfToUpdate
        log.info("Updated portfolio "+str(x))
        print("Long Positions")
        print([y.symbol for y in context.s0_rotPFs[x].longStockSID]) 
        print(context.s0_rotPFs[x].numLongPos)
        print("Short Positions")
        print([y.symbol for y in context.s0_rotPFs[x].shortStockSID])
        print(context.s0_rotPFs[x].numShortPos)                
                
        context.s0_pfToUpdate = (context.s0_pfToUpdate + 1)%context.s0_numberOfPF
        
#UTILITIES
class s0_dotDict:
    #This class allows .notation for organizing data in context
    def __init__(self):
        pass
        
def s0_time_lag(df):
    # using pandas' tshift shift index by N days
    # e.g. March 23rd will become March 24th.
    N  = 1
    df = df.tshift(N, freq='b')
    #previewFetch(df)
    return df

def s0_previewFetch(df):
    log.info('Previewing the fetched CSV file')
    log.info(df.tail())
    return df    

def s0_closeAnyOpenOrders(stock):  
    orders = get_open_orders(stock)  
    if orders:  
        for order in orders:  
             message = 'Canceling order for {amount} shares in {stock}'  
             message = message.format(amount=order.amount, stock=stock)  
             #log.debug(message)  
             cancel_order(order)

def s1_initialize(context):
    context.context[1].setnumber = 3 
    context.context[1].stk = [[sid(3443),sid(33856),sid(8329)], [sid(2621),sid(2368),sid(8306)],[sid(24833),sid(5213),sid(16108)]]
    context.context[1].n_dim_state = 3
    context.context[1].y = []
    context.context[1].x = []
    context.context[1].beta = []
    context.context[1].rollingbeta1 = []
    context.context[1].rollingbeta2 = []
    context.context[1].P = []
    context.context[1].R = []
    context.context[1].sqrt_Q = []
    context.context[1].pos = []
    context.context[1].open_finished = []
    context.context[1].PL = []
    context.context[1].cashpos = []
    context.context[1].portpos = []
    context.context[1].cycle_return = []
    context.context[1].cumulative_return = []
    context.context[1].squaring = []
    context.context[1].squaring_target = []
    context.context[1].squaring_id = []
    context.context[1].costbasis = []
    context.context[1].stocks_filled = []
    context.context[1].squaring_cost = []
    context.context[1].squaring_finished = []
    context.context[1].squaring_unfinished = []
    context.context[1].stoploss = []
    context.context[1].stoplossCount = []
    context.context[1].uncertain = []
    context.context[1].beta1std = []
    context.context[1].beta2std = []
    
    for i in range(0,context.context[1].setnumber):
        context.context[1].y.append(context.context[1].stk[i][0])
        x = []
        x.append(context.context[1].stk[i][1])
        x.append(context.context[1].stk[i][2])
        context.context[1].x.append(x)
        context.context[1].rollingbeta1.append([0,0,0,0,0])
        context.context[1].rollingbeta2.append([0,0,0,0,0])
        P = np.zeros((context.context[1].n_dim_state, context.context[1].n_dim_state))
        context.context[1].P.append(P)
        R = None
        context.context[1].R.append(R)
        context.context[1].sqrt_Q.append(0)
        pos = "none"
        context.context[1].pos.append(pos)
        context.context[1].open_finished.append(1)
        cashpos = context.context[1].portfolio.starting_cash / context.context[1].setnumber
        portpos = context.context[1].portfolio.starting_cash / context.context[1].setnumber
        context.context[1].PL.append(0)
        context.context[1].cashpos.append(cashpos)
        context.context[1].portpos.append(portpos)
        context.context[1].cycle_return.append([0,0,0])
        context.context[1].cumulative_return.append([0,0,0])
        context.context[1].stoploss.append(0)
        context.context[1].stoplossCount.append(0)
        context.context[1].squaring.append(0)
        context.context[1].squaring_target.append([0,0,0])
        context.context[1].squaring_id.append([0,0,0])
        context.context[1].costbasis.append([0,0,0])
        context.context[1].stocks_filled.append([0,0,0])
        context.context[1].squaring_cost.append([0,0,0])
        context.context[1].squaring_finished.append([1,1,1])
        context.context[1].squaring_unfinished.append(0)
        context.context[1].uncertain.append(0)
        context.context[1].beta1std.append(0)
        context.context[1].beta2std.append(0)
        
                       
    
    #delta will decide the value of the covariance of the transition noise
    context.context[1].delta = 0.0001
    #Vw is the covariance of the transition noise 
    context.context[1].Vw = context.context[1].delta / (1 - context.context[1].delta) * np.eye(context.context[1].n_dim_state)
    #Ve is the covariance of the measurement noise
    context.context[1].Ve = 0.25
    
    
    context.context[1].beta = [[0.87, 0.27, 0.25],[0.34, -0.13, 0.23],[0.99, 0.48, 0.26]]

    context.context[1].day = None
    context.context[1].dateCounter = 0
    context.context[1].activateDC = 0

def s1_kf(context,data,i):
    x = np.hstack([[data.current(sec, 'price') for sec in context.context[1].x[i]], 1.0]).reshape((1, context.context[1].n_dim_state))
    y = data.current(context.context[1].y[i], 'price')
    # update Kalman filter with latest price
    if context.context[1].R[i] is not None:
        context.context[1].R[i] = context.context[1].P[i] + context.context[1].Vw
    else:
        context.context[1].R[i] = np.zeros((context.context[1].n_dim_state, context.context[1].n_dim_state))

    yhat = x.dot(context.context[1].beta[i])
    Q = x.dot(context.context[1].R[i]).dot(x.T) + context.context[1].Ve
    sqrt_Q = np.sqrt(Q)
    sqrt_Q = sqrt_Q[0][0]
    context.context[1].sqrt_Q[i] = sqrt_Q
    e = y - yhat
    K = context.context[1].R[i].dot(x.T) / Q
    beta = context.context[1].beta[i] + K.flatten() * e
    context.context[1].beta[i] = beta.tolist()
    context.context[1].rollingbeta1[i][4] = context.context[1].rollingbeta1[i][3]
    context.context[1].rollingbeta1[i][3] = context.context[1].rollingbeta1[i][2]
    context.context[1].rollingbeta1[i][2] = context.context[1].rollingbeta1[i][1]
    context.context[1].rollingbeta1[i][1] = context.context[1].rollingbeta1[i][0]
    context.context[1].rollingbeta1[i][0] = context.context[1].beta[i][0]
    context.context[1].rollingbeta2[i][4] = context.context[1].rollingbeta2[i][3]
    context.context[1].rollingbeta2[i][3] = context.context[1].rollingbeta2[i][2]
    context.context[1].rollingbeta2[i][2] = context.context[1].rollingbeta2[i][1]
    context.context[1].rollingbeta2[i][1] = context.context[1].rollingbeta2[i][0]
    context.context[1].rollingbeta2[i][0] = context.context[1].beta[i][1]  
    context.context[1].beta1std[i] = np.std(context.context[1].rollingbeta1[i])
    context.context[1].beta2std[i] = np.std(context.context[1].rollingbeta2[i])
    
    context.context[1].P[i] = context.context[1].R[i] - K * x.dot(context.context[1].R[i])
    if context.context[1].uncertain[i] == 1:
        if (context.context[1].beta1std[i] < 0.02) & (context.context[1].beta2std[i] < 0.02):
            context.context[1].uncertain[i] = 0 
    #print context.context[1].beta    

def s1_before_trading_start(context,data):
    
    context.context[1].activateDC = 1
    for i in range(0,context.context[1].setnumber):
        s1_kf(context,data,i)
    for i in range(0,context.context[1].setnumber):
        if context.context[1].squaring[i] == 1:
            context.context[1].squaring_unfinished[i] = 1
            for j in range(0,len(context.context[1].stk[i])):
                context.context[1].squaring_cost[i][j] = context.context[1].squaring_cost[i][j] + get_order(context.context[1].squaring_id[i][j]).commission
  
def s1_find_signal(context, data, i):
    if context.context[1].open_finished[i] == 0:
        open_order_sum = 0 
        for sec in context.context[1].stk[i]:
            open_order_sum = open_order_sum + len(get_open_orders(sec))
        if open_order_sum == 0:
            context.context[1].open_finished[i] = 1
            print "portfolio {} {} position opened".format(i+1, context.context[1].pos[i])
            for j in range(0,len(context.context[1].stk[i])):        
                context.context[1].costbasis[i][j] = context.context[1].portfolio.positions[context.context[1].stk[i][j]].amount*context.context[1].portfolio.positions[context.context[1].stk[i][j]].cost_basis
                context.context[1].cashpos[i] = context.context[1].cashpos[i] - context.context[1].costbasis[i][j]    
            
        #print "open order left", open_order_sum    
    else:
        y = data.current(context.context[1].y[i], 'price')
        x = [data.current(sec, 'price') for sec in context.context[1].x[i]]
        spread = y - x[0] * context.context[1].beta[i][0] - x[1] * context.context[1].beta[i][1] - context.context[1].beta[i][2]
        #when there is no position, check for signals
        if context.context[1].pos[i] == "none":
            if (spread < -0.5*context.context[1].sqrt_Q[i]):
                context.context[1].pos[i] = 'long'
                s1_my_long(context,data,i)
                
                #print spread
                #consider linear strategy
            elif (spread > 0.5*context.context[1].sqrt_Q[i]):    
                context.context[1].pos[i] = 'short'
                s1_my_short(context,data,i)
                #print spread

        if context.context[1].pos[i] == "long":
            portpos = context.context[1].portfolio.positions[context.context[1].stk[i][0]].amount*data.current(context.context[1].stk[i][0], 'price') + context.context[1].portfolio.positions[context.context[1].stk[i][1]].amount*data.current(context.context[1].stk[i][1], 'price') + context.context[1].portfolio.positions[context.context[1].stk[i][2]].amount*data.current(context.context[1].stk[i][2], 'price') + context.context[1].cashpos[i]
            PL = portpos - context.context[1].portpos[i]
            if PL < context.context[1].stoploss[i]:
                context.context[1].stoplossCount[i] = context.context[1].stoplossCount[i] + 1 
                print "portfolio {} stoploss {}".format(i+1, context.context[1].stoplossCount[i])
                if (context.context[1].beta1std[i] > 0.03) or (context.context[1].beta2std[i] > 0.03):
                    context.context[1].uncertain[i] = 1 
                    context.context[1].stoplossCount[i] = 0
                    
                    s1_start_squaring(context,data,i)
                 

                if context.context[1].stoplossCount[i] > 390:
                    if (context.context[1].beta1std[i] > 0.01) or (context.context[1].beta2std[i] > 0.01):
                        context.context[1].uncertain[i] = 1 
                        context.context[1].stoplossCount[i] = 0

                        s1_start_squaring(context,data,i)
                     
                        
            elif spread > 0:
                context.context[1].stoplossCount[i] = 0
                s1_start_squaring(context,data,i)
         
        if context.context[1].pos[i] == "short":
            portpos = context.context[1].portfolio.positions[context.context[1].stk[i][0]].amount*data.current(context.context[1].stk[i][0], 'price') + context.context[1].portfolio.positions[context.context[1].stk[i][1]].amount*data.current(context.context[1].stk[i][1], 'price') + context.context[1].portfolio.positions[context.context[1].stk[i][2]].amount*data.current(context.context[1].stk[i][2], 'price') + context.context[1].cashpos[i]
            PL = portpos - context.context[1].portpos[i]
            if PL < context.context[1].stoploss[i]:
                context.context[1].stoplossCount[i] = context.context[1].stoplossCount[i] + 1 
                print "portfolio {} stoploss {}".format(i+1, context.context[1].stoplossCount[i])
                if (context.context[1].beta1std[i] > 0.03) or (context.context[1].beta2std[i] > 0.03):
                    context.context[1].uncertain[i] = 1 
                    context.context[1].stoplossCount[i] = 0

                    s1_start_squaring(context,data,i)
              
                if context.context[1].stoplossCount[i] > 390:
                    if (context.context[1].beta1std[i] > 0.01) or (context.context[1].beta2std[i] > 0.01):
                        context.context[1].uncertain[i] = 1 
                        context.context[1].stoplossCount[i] = 0
                        s1_start_squaring(context,data,i)
               

            elif spread < 0:
                context.context[1].stoplossCount[i] = 0
                s1_start_squaring(context,data,i)
       


                   
def s1_start_squaring(context, data, i):
    context.context[1].squaring[i] = 1 
    for j in range(0,len(context.context[1].stk[i])):        
        context.context[1].squaring_target[i][j] = -1* context.context[1].portfolio.positions[context.context[1].stk[i][j]].amount
        context.context[1].squaring_id[i][j] = make_order(context, data, order_target_percent, context.context[1].stk[i][j] ,0, 0, 1)
        context.context[1].squaring_finished[i][j] = 0
    print "starting to square portfolio {}".format(i+1)
    

def s1_finish_squaring(context,data,i):
    for j in range(0, len(context.context[1].stk[i])):
        context.context[1].squaring_cost[i][j] = context.context[1].squaring_cost[i][j] + get_order(context.context[1].squaring_id[i][j]).commission
        context.context[1].cashpos[i] = context.context[1].cashpos[i] - context.context[1].squaring_cost[i][j]
        context.context[1].squaring_cost[i][j] = 0
        context.context[1].squaring_target[i][j] = 0
        context.context[1].stocks_filled[i][j] = 0
    context.context[1].PL[i] = context.context[1].cashpos[i] - context.context[1].portpos[i]
#    cycle_return = context.context[1].PL[i] / context.context[1].portpos[i]
    context.context[1].cycle_return[i] = context.context[1].PL[i] / context.context[1].portpos[i]
    context.context[1].portpos[i] = context.context[1].cashpos[i]
    context.context[1].cumulative_return[i] = context.context[1].portpos[i] / (context.context[1].portfolio.starting_cash / context.context[1].setnumber) - 1 
    
    context.context[1].squaring[i] = 0
    print "portfolio {} {} position squared, returned {:.1%} this cycle, {:.1%} cumulatively.".format(i+1,context.context[1].pos[i],context.context[1].cycle_return[i], context.context[1].cumulative_return[i])
    context.context[1].pos[i] = "none"
    
        

    

def s1_handle_data(context, data):
    if context.context[1].activateDC==1:
        context.context[1].dateCounter = context.context[1].dateCounter+1
        context.context[1].activateDC=0
    if context.context[1].dateCounter > 0:
        for i in range(0,context.context[1].setnumber):
            if context.context[1].squaring[i] == 1:
                if context.context[1].squaring_unfinished[i] == 1:
                    for j in range(0, len(context.context[1].stk[i])):
                        if context.context[1].squaring_unfinished[i] == 1:
                            #print context.context[1].stk[i][j]
                            #print context.context[1].squaring_target[i][j]
                            #print context.context[1].stocks_filled[i][j]
                            context.context[1].squaring_target[i][j] = context.context[1].squaring_target[i][j] - context.context[1].stocks_filled[i][j]
                            if context.context[1].squaring_target[i][j] != 0:
                                #print context.context[1].squaring_target[i][j]
                                context.context[1].squaring_id[i][j] = make_order(context, data, order_target_percent, context.context[1].stk[i][j],0, 0, 1)
                                #print context.context[1].squaring_id[i][j]
                            context.context[1].stocks_filled[i][j] = 0 
                    context.context[1].squaring_unfinished[i] = 0
                    
                for j in range(0, len(context.context[1].stk[i])):  
                    #print context.context[1].squaring_id[i][j]
                    if context.context[1].squaring_finished[i][j] == 0:
                        new_order = get_order(context.context[1].squaring_id[i][j]).filled - context.context[1].stocks_filled[i][j]
                        new_cost = data.current(context.context[1].stk[i][j], 'price') * new_order
                        context.context[1].stocks_filled[i][j] = get_order(context.context[1].squaring_id[i][j]).filled
                        context.context[1].squaring_cost[i][j] = context.context[1].squaring_cost[i][j] + new_cost
                        if get_order(context.context[1].squaring_id[i][j]).filled == context.context[1].squaring_target[i][j]:
                            context.context[1].squaring_finished[i][j] = 1
                        
                if context.context[1].squaring_finished[i] == [1,1,1]:
                    s1_finish_squaring(context,data,i)
            else:
                if context.context[1].uncertain[i] == 0:
                    exchange_time = get_datetime().astimezone(pytz.timezone('US/Eastern'))
                    if exchange_time.hour < 15:
                        if exchange_time.hour >= 9:
                            s1_find_signal(context,data,i)


def s1_my_long(context,data,i):
    print "longing set {}".format(i+1)
    context.context[1].open_finished[i] = 0
    y = data.current(context.context[1].y[i], 'price')
    x = [data.current(sec, 'price') for sec in context.context[1].x[i]]
    spread = y - x[0] * context.context[1].beta[i][0] - x[1] * context.context[1].beta[i][1] - context.context[1].beta[i][2]
    ratio = spread / context.context[1].sqrt_Q[i]
    ratio = np.absolute(ratio)
    #print "ratio1"
    #print ratio
    ratio = np.amin([0.5*ratio,0.5])
    #print "ratio capped"
    #print ratio
    if (context.context[1].beta[i][0] >0) & (context.context[1].beta[i][1] > 0):
       # print "case1"
        make_order(context, data, order_target_value, context.context[1].y[i], ratio*context.context[1].portpos[i], 0, 1)
        stock1T = context.context[1].beta[i][0]*data.current(context.context[1].x[i][0], 'price')
        stock2T = context.context[1].beta[i][1]*data.current(context.context[1].x[i][1], 'price')
        stock1percent = stock1T/(stock1T + stock2T + context.context[1].beta[i][2])
        stock2percent = stock2T/(stock1T + stock2T + context.context[1].beta[i][2])
        """
        context.context[1].stk1pos[i] = ratio*context.context[1].portpos[i]
        context.context[1].stk2pos[i] = -1*ratio*stock1percent*context.context[1].portpos[i] 
        context.context[1].stk3pos[i] = -1*ratio*stock2percent*context.context[1].portpos[i]
        context.context[1].cashpos[i] = context.context[1].portpos[i] - context.context[1].stk1pos[i] - context.context[1].stk2pos[i] - context.context[1].stk3pos[i]
        """
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        make_order(context,data,order_target_value,context.context[1].x[i][0], -1*ratio*stock1percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].x[i][1], -1*ratio*stock2percent*context.context[1].portpos[i],0,1)
       
    elif (context.context[1].beta[i][0] >0) & (context.context[1].beta[i][1] < 0):
       # print "case2"
        make_order(context,data,order_target_value,context.context[1].x[i][0], -1*ratio*context.context[1].portpos[i],0,1)
        yT = data.current(context.context[1].y[i], 'price')
        stock2T = context.context[1].beta[i][1]*data.current(context.context[1].x[i][1], 'price')
        ypercent = yT/(yT - stock2T - context.context[1].beta[i][2])
        stock2percent = -1 * stock2T/(yT - stock2T - context.context[1].beta[i][2])
        
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        
        make_order(context,data,order_target_value,context.context[1].x[i][1], ratio*stock2percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].y[i], ratio*ypercent*context.context[1].portpos[i],0,1)

    elif (context.context[1].beta[i][0] <0) & (context.context[1].beta[i][1] > 0):
        #print "case3"
        make_order(context,data,order_target_value,context.context[1].x[i][1], -1*ratio*context.context[1].portpos[i],0,1)
        yT = data.current(context.context[1].y[i], 'price')
        stock1T = context.context[1].beta[i][0]*data.current(context.context[1].x[i][0], 'price')
        ypercent = yT/(yT - stock1T - context.context[1].beta[i][2])
        stock1percent = -1* stock1T/(yT - stock1T - context.context[1].beta[i][2])
        """
        context.context[1].stk1pos[i] = ratio*ypercent*context.context[1].portpos[i]
        context.context[1].stk2pos[i] = 1*ratio*stock1percent*context.context[1].portpos[i]
        context.context[1].stk3pos[i] = -1*ratio*context.context[1].portpos[i]
        
        context.context[1].cashpos[i] = context.context[1].portpos[i] - context.context[1].stk1pos[i] - context.context[1].stk2pos[i] - context.context[1].stk3pos[i]
        """
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        make_order(context,data,order_target_value,context.context[1].x[i][0], ratio*stock1percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].y[i], ratio*ypercent*context.context[1].portpos[i],0,1)   
        
def s1_my_short(context,data,i):    
    print "shorting set {}".format(i+1)
    context.context[1].open_finished[i] = 0
    y = data.current(context.context[1].y[i], 'price')
    x = [data.current(sec, 'price') for sec in context.context[1].x[i]]
    spread = y - x[0] * context.context[1].beta[i][0] - x[1] * context.context[1].beta[i][1] - context.context[1].beta[i][2]
    ratio = spread / context.context[1].sqrt_Q[i]
    ratio = np.absolute(ratio)
    #print "ratio1"
    #print ratio
    ratio = np.amin([0.5*ratio,0.5])
    #print "ratio capped"
    #print ratio
    if (context.context[1].beta[i][0] >0) & (context.context[1].beta[i][1] > 0):
       # print "case1"
        make_order(context,data,order_target_value,context.context[1].y[i], -1*ratio*context.context[1].portpos[i],0,1)
        stock1T = context.context[1].beta[i][0]*data.current(context.context[1].x[i][0], 'price')
        stock2T = context.context[1].beta[i][1]*data.current(context.context[1].x[i][1], 'price')
        stock1percent = stock1T/(stock1T + stock2T + context.context[1].beta[i][2])
        stock2percent = stock2T/(stock1T + stock2T + context.context[1].beta[i][2])
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        make_order(context,data,order_target_value,context.context[1].x[i][0], 1*ratio*stock1percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].x[i][1], 1*ratio*stock2percent*context.context[1].portpos[i],0,1)
       
    elif (context.context[1].beta[i][0] >0) & (context.context[1].beta[i][1] < 0):
       # print "case2"
        make_order(context,data,order_target_value,context.context[1].x[i][0], 1*ratio*context.context[1].portpos[i],0,1)
        yT = data.current(context.context[1].y[i], 'price')
        stock2T = context.context[1].beta[i][1]*data.current(context.context[1].x[i][1], 'price')
        ypercent = yT/(yT - stock2T - context.context[1].beta[i][2])
        stock2percent = -1 * stock2T/(yT - stock2T - context.context[1].beta[i][2])
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        make_order(context,data,order_target_value,context.context[1].x[i][1], -1*ratio*stock2percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].y[i], -1*ratio*ypercent*context.context[1].portpos[i],0,1)

    elif (context.context[1].beta[i[0]] <0) & (context.context[1].beta[i[1]] > 0):
        #print "case3"
        make_order(context,data,order_target_value,context.context[1].x[i][1], 1*ratio*context.context[1].portpos[i],0,1)
        yT = data.current(context.context[1].y[i], 'price')
        stock1T = context.context[1].beta[i][0]*data.current(context.context[1].x[i][0], 'price')
        ypercent = yT/(yT - stock1T - context.context[1].beta[i][2])
        stock1percent = -1* stock1T/(yT - stock1T - context.context[1].beta[i][2])
        context.context[1].stoploss[i] = -0.05 * context.context[1].portpos[i]
        make_order(context,data,order_target_value,context.context[1].x[i][0], -1*ratio*stock1percent*context.context[1].portpos[i],0,1)
        make_order(context,data,order_target_value,context.context[1].y[i], -1*ratio*ypercent*context.context[1].portpos[i],0,1)  



